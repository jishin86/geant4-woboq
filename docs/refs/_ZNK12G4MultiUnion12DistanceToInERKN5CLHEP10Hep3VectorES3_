<dec f='codebrowser/source/geometry/solids/Boolean/include/G4MultiUnion.hh' l='92' type='G4double G4MultiUnion::DistanceToIn(const G4ThreeVector &amp; aPoint, const G4ThreeVector &amp; aDirection) const'/>
<inh f='codebrowser/source/geometry/management/include/G4VSolid.hh' l='130' c='_ZNK8G4VSolid12DistanceToInERKN5CLHEP10Hep3VectorES3_'/>
<def f='codebrowser/source/geometry/solids/Boolean/src/G4MultiUnion.cc' l='214' ll='245' type='G4double G4MultiUnion::DistanceToIn(const G4ThreeVector &amp; aPoint, const G4ThreeVector &amp; aDirection) const'/>
<doc f='codebrowser/source/geometry/solids/Boolean/src/G4MultiUnion.cc' l='203'>// Algorithm note: we have to look also for all other objects in next voxels,
// if the distance is not shorter ... we have to do it because,
// for example for objects which starts in first voxel in which they
// do not collide with direction line, but in second it collides...
// The idea of crossing voxels would be still applicable,
// because this way we could exclude from the testing such solids,
// which were found that obviously are not good candidates, because
// they would return infinity
// But if distance is smaller than the shift to next voxel, we can return
// it immediately
//______________________________________________________________________________</doc>
<doc f='codebrowser/source/geometry/solids/Boolean/include/G4MultiUnion.hh' l='91'>// Exact distance methods</doc>
