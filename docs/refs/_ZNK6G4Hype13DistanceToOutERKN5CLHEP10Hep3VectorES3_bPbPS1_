<dec f='codebrowser/source/geometry/solids/specific/include/G4Hype.hh' l='117' type='G4double G4Hype::DistanceToOut(const G4ThreeVector &amp; p, const G4ThreeVector &amp; v, const G4bool calcNorm = G4bool(false), G4bool * validNorm = 0, G4ThreeVector * n = 0) const'/>
<inh f='codebrowser/source/geometry/management/include/G4VSolid.hh' l='142' c='_ZNK8G4VSolid13DistanceToOutERKN5CLHEP10Hep3VectorES3_bPbPS1_'/>
<def f='codebrowser/source/geometry/solids/specific/src/G4Hype.cc' l='733' ll='896' type='G4double G4Hype::DistanceToOut(const G4ThreeVector &amp; p, const G4ThreeVector &amp; v, const G4bool calcNorm = G4bool(false), G4bool * validNorm = 0, G4ThreeVector * norm = 0) const'/>
<doc f='codebrowser/source/geometry/solids/specific/src/G4Hype.cc' l='725'>//
// Calculate distance to surface of shape from `inside&apos;, allowing for tolerance
//
// The situation here is much simplier than DistanceToIn(p,v). For
// example, there is no need to even check whether an intersection
// point is inside the boundary of a surface, as long as all surfaces 
// are checked and the smallest distance is used.
//</doc>
