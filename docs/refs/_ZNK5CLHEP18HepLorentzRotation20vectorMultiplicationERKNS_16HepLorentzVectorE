<dec f='codebrowser/source/externals/clhep/include/CLHEP/Vector/LorentzRotation.h' l='254' type='CLHEP::HepLorentzVector CLHEP::HepLorentzRotation::vectorMultiplication(const CLHEP::HepLorentzVector &amp; ) const'/>
<def f='codebrowser/source/externals/clhep/include/CLHEP/Vector/LorentzRotation.icc' l='264' ll='274' type='CLHEP::HepLorentzVector CLHEP::HepLorentzRotation::vectorMultiplication(const CLHEP::HepLorentzVector &amp; p) const'/>
<use f='codebrowser/source/externals/clhep/include/CLHEP/Vector/LorentzRotation.icc' l='278' u='c' c='_ZNK5CLHEP18HepLorentzRotationclERKNS_16HepLorentzVectorE'/>
<use f='codebrowser/source/externals/clhep/include/CLHEP/Vector/LorentzRotation.icc' l='283' u='c' c='_ZNK5CLHEP18HepLorentzRotationmlERKNS_16HepLorentzVectorE'/>
<doc f='codebrowser/source/externals/clhep/include/CLHEP/Vector/LorentzRotation.h' l='243'>// non-const but logically moot correction for accumulated roundoff errors
        // rectify averages the matrix with the orthotranspose of its actual
        // inverse (absent accumulated roundoff errors, the orthotranspose IS
        // the inverse)); this removes to first order those errors.
        // Then it formally decomposes that, extracts axis and delta for its
	// Rotation part, forms a LorentzRotation from a true HepRotation 
	// with those values of axis and delta, times the true Boost
	// with that boost vector.

  // ---------- Application:</doc>
<doc f='codebrowser/source/externals/clhep/include/CLHEP/Vector/LorentzRotation.icc' l='260'>// ----------  Properties:
                             
// ---------- Application:</doc>
<use f='codebrowser/source/externals/clhep/src/LorentzVectorL.cc' l='22' u='c' c='_ZN5CLHEP16HepLorentzVectormLERKNS_18HepLorentzRotationE'/>
<use f='codebrowser/source/externals/clhep/src/LorentzVectorL.cc' l='27' u='c' c='_ZN5CLHEP16HepLorentzVector9transformERKNS_18HepLorentzRotationE'/>
