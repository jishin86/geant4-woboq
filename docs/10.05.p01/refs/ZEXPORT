<def f='codebrowser/source/externals/zlib/src/compress.c' l='21' type='int'/>
<def f='codebrowser/source/externals/zlib/src/compress.c' l='67' type='int'/>
<doc f='codebrowser/source/externals/zlib/src/compress.c' l='10'>/* ===========================================================================
     Compresses the source buffer into the destination buffer. The level
   parameter has the same meaning as in deflateInit.  sourceLen is the byte
   length of the source buffer. Upon entry, destLen is the total size of the
   destination buffer, which must be at least 0.1% larger than sourceLen plus
   12 bytes. Upon exit, destLen is the actual size of the compressed buffer.

     compress2 returns Z_OK if success, Z_MEM_ERROR if there was not enough
   memory, Z_BUF_ERROR if there was not enough room in the output buffer,
   Z_STREAM_ERROR if the level parameter is invalid.
*/</doc>
<doc f='codebrowser/source/externals/zlib/src/compress.c' l='65'>/* ===========================================================================
 */</doc>
<def f='codebrowser/source/externals/zlib/src/crc32.c' l='236' type='unsigned long'/>
<doc f='codebrowser/source/externals/zlib/src/crc32.c' l='235'>/* ========================================================================= */</doc>
<def f='codebrowser/source/externals/zlib/src/deflate.c' l='227' type='int'/>
<def f='codebrowser/source/externals/zlib/src/deflate.c' l='239' type='int'/>
<def f='codebrowser/source/externals/zlib/src/deflate.c' l='375' type='int'/>
<def f='codebrowser/source/externals/zlib/src/deflate.c' l='444' type='int'/>
<def f='codebrowser/source/externals/zlib/src/deflate.c' l='466' type='int'/>
<def f='codebrowser/source/externals/zlib/src/deflate.c' l='504' type='int'/>
<def f='codebrowser/source/externals/zlib/src/deflate.c' l='516' type='int'/>
<def f='codebrowser/source/externals/zlib/src/deflate.c' l='527' type='int'/>
<def f='codebrowser/source/externals/zlib/src/deflate.c' l='541' type='int'/>
<def f='codebrowser/source/externals/zlib/src/deflate.c' l='567' type='int'/>
<def f='codebrowser/source/externals/zlib/src/deflate.c' l='616' type='int'/>
<def f='codebrowser/source/externals/zlib/src/deflate.c' l='762' type='int'/>
<def f='codebrowser/source/externals/zlib/src/deflate.c' l='1075' type='int'/>
<def f='codebrowser/source/externals/zlib/src/deflate.c' l='1101' type='int'/>
<doc f='codebrowser/source/externals/zlib/src/deflate.c' l='226'>/* ========================================================================= */</doc>
<doc f='codebrowser/source/externals/zlib/src/deflate.c' l='238'>/* ========================================================================= */</doc>
<doc f='codebrowser/source/externals/zlib/src/deflate.c' l='374'>/* ========================================================================= */</doc>
<doc f='codebrowser/source/externals/zlib/src/deflate.c' l='443'>/* ========================================================================= */</doc>
<doc f='codebrowser/source/externals/zlib/src/deflate.c' l='465'>/* ========================================================================= */</doc>
<doc f='codebrowser/source/externals/zlib/src/deflate.c' l='503'>/* ========================================================================= */</doc>
<doc f='codebrowser/source/externals/zlib/src/deflate.c' l='515'>/* ========================================================================= */</doc>
<doc f='codebrowser/source/externals/zlib/src/deflate.c' l='526'>/* ========================================================================= */</doc>
<doc f='codebrowser/source/externals/zlib/src/deflate.c' l='540'>/* ========================================================================= */</doc>
<doc f='codebrowser/source/externals/zlib/src/deflate.c' l='566'>/* ========================================================================= */</doc>
<doc f='codebrowser/source/externals/zlib/src/deflate.c' l='615'>/* ========================================================================= */</doc>
<doc f='codebrowser/source/externals/zlib/src/deflate.c' l='761'>/* ========================================================================= */</doc>
<doc f='codebrowser/source/externals/zlib/src/deflate.c' l='1074'>/* ========================================================================= */</doc>
<doc f='codebrowser/source/externals/zlib/src/deflate.c' l='1096'>/* =========================================================================
 * Copy the source state to the destination state.
 * To simplify the source, this is not supported for 16-bit MSDOS (which
 * doesn&apos;t have enough memory anyway to duplicate compression states).
 */</doc>
<def f='codebrowser/source/externals/zlib/src/gzclose.c' l='11' type='int'/>
<doc f='codebrowser/source/externals/zlib/src/gzclose.c' l='8'>/* gzclose() is in a separate file so that it is linked in only if it is used.
   That way the other gzclose functions can be used instead to avoid linking in
   unneeded compression or decompression routines. */</doc>
<def f='codebrowser/source/externals/zlib/src/gzlib.c' l='270' type='gzFile'/>
<def f='codebrowser/source/externals/zlib/src/gzlib.c' l='278' type='gzFile'/>
<def f='codebrowser/source/externals/zlib/src/gzlib.c' l='286' type='gzFile'/>
<doc f='codebrowser/source/externals/zlib/src/gzlib.c' l='269'>/* -- see zlib.h -- */</doc>
<doc f='codebrowser/source/externals/zlib/src/gzlib.c' l='277'>/* -- see zlib.h -- */</doc>
<doc f='codebrowser/source/externals/zlib/src/gzlib.c' l='285'>/* -- see zlib.h -- */</doc>
<def f='codebrowser/source/externals/zlib/src/gzread.c' l='375' type='int'/>
<def f='codebrowser/source/externals/zlib/src/gzread.c' l='447' type='int'/>
<def f='codebrowser/source/externals/zlib/src/gzread.c' l='476' type='int'/>
<def f='codebrowser/source/externals/zlib/src/gzread.c' l='483' type='int'/>
<def f='codebrowser/source/externals/zlib/src/gzread.c' l='607' type='int'/>
<def f='codebrowser/source/externals/zlib/src/gzread.c' l='627' type='int'/>
<doc f='codebrowser/source/externals/zlib/src/gzread.c' l='374'>/* -- see zlib.h -- */</doc>
<doc f='codebrowser/source/externals/zlib/src/gzread.c' l='482'>/* -- see zlib.h -- */</doc>
<doc f='codebrowser/source/externals/zlib/src/gzread.c' l='606'>/* -- see zlib.h -- */</doc>
<doc f='codebrowser/source/externals/zlib/src/gzread.c' l='626'>/* -- see zlib.h -- */</doc>
<def f='codebrowser/source/externals/zlib/src/gzwrite.c' l='246' type='int'/>
<def f='codebrowser/source/externals/zlib/src/gzwrite.c' l='304' type='int'/>
<def f='codebrowser/source/externals/zlib/src/gzwrite.c' l='352' type='int'/>
<def f='codebrowser/source/externals/zlib/src/gzwrite.c' l='559' type='int'/>
<def f='codebrowser/source/externals/zlib/src/gzwrite.c' l='591' type='int'/>
<def f='codebrowser/source/externals/zlib/src/gzwrite.c' l='633' type='int'/>
<doc f='codebrowser/source/externals/zlib/src/gzwrite.c' l='245'>/* -- see zlib.h -- */</doc>
<doc f='codebrowser/source/externals/zlib/src/gzwrite.c' l='303'>/* -- see zlib.h -- */</doc>
<doc f='codebrowser/source/externals/zlib/src/gzwrite.c' l='351'>/* -- see zlib.h -- */</doc>
<doc f='codebrowser/source/externals/zlib/src/gzwrite.c' l='558'>/* -- see zlib.h -- */</doc>
<doc f='codebrowser/source/externals/zlib/src/gzwrite.c' l='590'>/* -- see zlib.h -- */</doc>
<doc f='codebrowser/source/externals/zlib/src/gzwrite.c' l='632'>/* -- see zlib.h -- */</doc>
<def f='codebrowser/source/externals/zlib/src/infback.c' l='28' type='int'/>
<def f='codebrowser/source/externals/zlib/src/infback.c' l='250' type='int'/>
<def f='codebrowser/source/externals/zlib/src/infback.c' l='631' type='int'/>
<doc f='codebrowser/source/externals/zlib/src/infback.c' l='21'>/*
   strm provides memory allocation functions in zalloc and zfree, or
   Z_NULL to use the library memory allocation functions.

   windowBits is in the range 8..15, and window is a user-supplied
   window and output buffer that is 2**windowBits bytes.
 */</doc>
<doc f='codebrowser/source/externals/zlib/src/infback.c' l='223'>/*
   strm provides the memory allocation functions and window buffer on input,
   and provides information on the unused input on return.  For Z_DATA_ERROR
   returns, strm will also provide an error message.

   in() and out() are the call-back input and output functions.  When
   inflateBack() needs more input, it calls in().  When inflateBack() has
   filled the window with output, or when it completes with data in the
   window, it calls out() to write out the data.  The application must not
   change the provided input until in() is called again or inflateBack()
   returns.  The application must not change the window/output buffer until
   inflateBack() returns.

   in() and out() are called with a descriptor parameter provided in the
   inflateBack() call.  This parameter can be a structure that provides the
   information required to do the read or write, as well as accumulated
   information on the input and output such as totals and check values.

   in() should return zero on failure.  out() should return non-zero on
   failure.  If either in() or out() fails, than inflateBack() returns a
   Z_BUF_ERROR.  strm-&gt;next_in can be checked for Z_NULL to see whether it
   was in() or out() that caused in the error.  Otherwise,  inflateBack()
   returns Z_STREAM_END on success, Z_DATA_ERROR for an deflate format
   error, or Z_MEM_ERROR if it could not allocate memory for the state.
   inflateBack() can also return Z_STREAM_ERROR if the input parameters
   are not correct, i.e. strm is Z_NULL or the state was not initialized.
 */</doc>
<def f='codebrowser/source/externals/zlib/src/inflate.c' l='119' type='int'/>
<def f='codebrowser/source/externals/zlib/src/inflate.c' l='144' type='int'/>
<def f='codebrowser/source/externals/zlib/src/inflate.c' l='157' type='int'/>
<def f='codebrowser/source/externals/zlib/src/inflate.c' l='195' type='int'/>
<def f='codebrowser/source/externals/zlib/src/inflate.c' l='239' type='int'/>
<def f='codebrowser/source/externals/zlib/src/inflate.c' l='247' type='int'/>
<def f='codebrowser/source/externals/zlib/src/inflate.c' l='622' type='int'/>
<def f='codebrowser/source/externals/zlib/src/inflate.c' l='1277' type='int'/>
<def f='codebrowser/source/externals/zlib/src/inflate.c' l='1291' type='int'/>
<def f='codebrowser/source/externals/zlib/src/inflate.c' l='1314' type='int'/>
<def f='codebrowser/source/externals/zlib/src/inflate.c' l='1349' type='int'/>
<def f='codebrowser/source/externals/zlib/src/inflate.c' l='1400' type='int'/>
<def f='codebrowser/source/externals/zlib/src/inflate.c' l='1451' type='int'/>
<def f='codebrowser/source/externals/zlib/src/inflate.c' l='1461' type='int'/>
<def f='codebrowser/source/externals/zlib/src/inflate.c' l='1508' type='int'/>
<def f='codebrowser/source/externals/zlib/src/inflate.c' l='1526' type='int'/>
<doc f='codebrowser/source/externals/zlib/src/inflate.c' l='540'>/*
   inflate() uses a state machine to process as much input data and generate as
   much output data as possible before returning.  The state machine is
   structured roughly as follows:

    for (;;) switch (state) {
    ...
    case STATEn:
        if (not enough input data or output space to make progress)
            return;
        ... make progress ...
        state = STATEm;
        break;
    ...
    }

   so when inflate() is called again, the same case is attempted again, and
   if the appropriate resources are provided, the machine proceeds to the
   next state.  The NEEDBITS() macro is usually the way the state evaluates
   whether it can proceed or should return.  NEEDBITS() does the return if
   the requested bits are not available.  The typical use of the BITS macros
   is:

        NEEDBITS(n);
        ... do something with BITS(n) ...
        DROPBITS(n);

   where NEEDBITS(n) either returns from inflate() if there isn&apos;t enough
   input left to load n bits into the accumulator, or it continues.  BITS(n)
   gives the low n bits in the accumulator.  When done, DROPBITS(n) drops
   the low n bits off the accumulator.  INITBITS() clears the accumulator
   and sets the number of available bits to zero.  BYTEBITS() discards just
   enough bits to put the accumulator on a byte boundary.  After BYTEBITS()
   and a NEEDBITS(8), then BITS(8) would return the next byte in the stream.

   NEEDBITS(n) uses PULLBYTE() to get an available byte of input, or to return
   if there is no input available.  The decoding of variable length codes uses
   PULLBYTE() directly in order to pull just enough bytes to decode the next
   code, and no more.

   Some states loop until they get enough input, making sure that enough
   state information is maintained to continue the loop where it left off
   if NEEDBITS() returns in the loop.  For example, want, need, and keep
   would all have to actually be part of the saved state in case NEEDBITS()
   returns:

    case STATEw:
        while (want &lt; need) {
            NEEDBITS(n);
            keep[want++] = BITS(n);
            DROPBITS(n);
        }
        state = STATEx;
    case STATEx:

   As shown above, if the next state is also the next case, then the break
   is omitted.

   A state may also return if there is not enough output space available to
   complete that state.  Those states are copying stored data, writing a
   literal byte, and copying a matching string.

   When returning, a &quot;goto inf_leave&quot; is used to update the total counters,
   update the check value, and determine whether any progress has been made
   during that inflate() call in order to return the proper return code.
   Progress is defined as a change in either strm-&gt;avail_in or strm-&gt;avail_out.
   When there is a window, goto inf_leave will update the window with the last
   output written.  If a goto inf_leave occurs in the middle of decompression
   and there is no window currently, goto inf_leave will create one and copy
   output to the window for the next call of inflate().

   In this implementation, the flush parameter of inflate() only affects the
   return code (per zlib.h).  inflate() always writes as much as possible to
   strm-&gt;next_out, given the space available and the provided input--the effect
   documented in zlib.h of Z_SYNC_FLUSH.  Furthermore, inflate() always defers
   the allocation of and copying into a sliding window until necessary, which
   provides the effect documented in zlib.h for Z_FINISH when the entire input
   stream available.  So the only thing the flush parameter actually does is:
   when flush is set to Z_FINISH, inflate() cannot return Z_OK.  Instead it
   will return Z_BUF_ERROR if it has not reached the end of the stream.
 */</doc>
<doc f='codebrowser/source/externals/zlib/src/inflate.c' l='1443'>/*
   Returns true if inflate is currently at the end of a block generated by
   Z_SYNC_FLUSH or Z_FULL_FLUSH. This function is used by one PPP
   implementation to provide an additional safety check. PPP uses
   Z_SYNC_FLUSH but removes the length bytes of the resulting empty stored
   block. When decompressing, PPP checks that at the end of input packet,
   inflate is waiting for these length bytes.
 */</doc>
<def f='codebrowser/source/externals/zlib/src/uncompr.c' l='26' type='int'/>
<def f='codebrowser/source/externals/zlib/src/uncompr.c' l='85' type='int'/>
<doc f='codebrowser/source/externals/zlib/src/uncompr.c' l='10'>/* ===========================================================================
     Decompresses the source buffer into the destination buffer.  *sourceLen is
   the byte length of the source buffer. Upon entry, *destLen is the total size
   of the destination buffer, which must be large enough to hold the entire
   uncompressed data. (The size of the uncompressed data must have been saved
   previously by the compressor and transmitted to the decompressor by some
   mechanism outside the scope of this compression library.) Upon exit,
   *destLen is the size of the decompressed data and *sourceLen is the number
   of source bytes consumed. Upon return, source + *sourceLen points to the
   first unused input byte.

     uncompress returns Z_OK if success, Z_MEM_ERROR if there was not enough
   memory, Z_BUF_ERROR if there was not enough room in the output buffer, or
   Z_DATA_ERROR if the input data was corrupted, including if the input data is
   an incomplete zlib stream.
*/</doc>
<def f='codebrowser/source/externals/zlib/src/zutil.c' l='26' type='const char *'/>
